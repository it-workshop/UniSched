# Взаимодействие с объектами

Q: Как создать объект?

A: Достаточно вызвать фабричный метод create класса Core::AbstractUI. Этот
метод находится в protected секции, поэтому вызываться должен из класса,
реализующего пользовательский интерфейс. Примеры:

    Object * John = create<Person>();
    Object * Party = create<Event>();
    Object * Scorpions = create<Group>();


Q: Почему все созданные объекты имеют тип 'Object *'?

A: Можно указать и точное имя объекта, однако это ничего не изменит. Все
методы, необходимые для работы объявлены и реализованы в классе Object.


Q: Я создал объект, что мне теперь делать?

A: Теперь можно его изменять. Для простоты реализации все объекты создаются
пустыми. С помощью метода update(name, value) можно установить значение любого
поля объекта. Будьте осторожны, если полю уже установлено значение одного типа,
а вы попробуете ему присвоить значение другого типа, произойдет исключительная
ситуация boost::bad_any_cast.

Q: Я еще не назначал полю %fieldname% значение, почему я получил исключение?

A: У каждого типа объектов есть поля, которые должны иметь стого определенный
тип, а некоторые, вдобавок, и ограниченый диапозон значений. Чтобы не путаться
вот полный список.

    +-----------------+-------------+---------------------+
    | Имя поля        | Тип поля    | Допустимые значения |
    +=================+=============+=====================+
    | Person                                              |
    +-----------------+-------------+---------------------+
    | name            | std::string | Любые               |
    +-----------------+-------------+---------------------+
    | surname         | std::string | Любые               |
    +-----------------+-------------+---------------------+
    | birthday        | time_t      | Любые               |
    +-----------------+-------------+---------------------+
    | sex             | std::string | "MALE", "FEMALE"    |
    +-----------------+-------------+---------------------+
    | groups          | -           | -                   |
    +=================+=============+=====================+
    | Group                                               |
    +-----------------+-------------+---------------------+
    | name            | std::string | Любые               |
    +-----------------+-------------+---------------------+
    | people          | -           | -                   |
    +-----------------+-------------+---------------------+
    | parent_groups   | -           | -                   |
    +-----------------+-------------+---------------------+
    | children_groups | -           | -                   |
    +=================+=============+=====================+
    | Event                                               |
    +-----------------+-------------+---------------------+
    | name            | std::string | Любые               |
    +-----------------+-------------+---------------------+
    | begin           | time_t      | Любые               |
    +-----------------+-------------+---------------------+
    | duration        | time_t      | Любые               |
    +-----------------+-------------+---------------------+
    | people          | -           | -                   |
    +-----------------+-------------+---------------------+
    | children_groups | -           | -                   |
    +-----------------+-------------+---------------------+


Q: Почему у половины полей в таблице не указаны тип и допустимые значения?

A: Эти поля нельзя изменить с помощью метода update. Их тип:
std::vector<Object *>. Они хранят связи с другими объектами. В данную таблицу
они занесены, чтобы обозначить, что эти поля заняты.

Q: Как сохранить данные созданных объектов на диск?

A:
**ATTENTION: данный ответ подразумевает сборку с параметром WITH\_YAML=Y.**

**ATTENTION: данный ответ может стать недействительным в ближайшее время.**

Полное резервное копирование данных производится методом AbstractUI::dump(std::string).
Аргументом является имя файла, в котором будут храниться данные всех созданных объектов
(в формате языка YAML). Формат генирируемого файла следующий:

    +-----------------------------------+
    | - Object: Person[Group|Event]     |
    |   ID: 7890                        |
    |   VCard:                          |
    |     name: William                 |
    |     surname: Gates                |
    |     sex: MALE                     |
    |     birthday: 19011958            |
    | - Object: ... # etc.              |
    +-----------------------------------+
    
При использования метода dump() происходит создание нового файла, если с файл с тем же
именем уже существует, то он будет перезаписан.


Q: Как загрузить данные с диска?

A: С другой стороны, для загрузки информации об объектах их файла используется
метод AbstractUI::load(std::string). В качестве аргемента -- имя файла с
данными объектов на языке YAML. Метод возвращает bool в зависимости от того,
успешно ли прошел парсинг.

Пример использования можно найти в src/module/dummy.cpp (пример основан на файле 
fixtures/database.yaml).


Q: Как я могу менять связи между объектами?

A: С помощью методов connect и disconnect можно связывать и отвязывать
объекты. Например:

    Freddy->connect(Queen);
    Beatles->connect(John);

    ITMonsters->connect(apple);

    Party->connect(John);
    Paul->connect(Party);
    Party->connect(Girls);


Q: Я хочу связать две группы, метод connect какой из них мне необходимо
вызвать?

A: Требуется вызвать метод той группы, в которую включается более мелкая
группа. Так, в предыдущем примере в группу ITMonsters включается группа apple.


Q: Все прекрасно, но как мне просмотреть поля объектов?

A: Достаточно вызвать метод read(name), чтобы получить значение поля. Учтите,
что все поля хранятся в виде boost::any, поэтому они требуют
преобразования.  Например:

    Object *John = create<Person>();
    John.update("name", std::string("John");

    std::cout << boost::any_cast<const std::string>(John.read("name"))
        << std::endl;

Вывод:
    
    John


Q: А можно как-то получить все поля объекта сразу, или список их имен?

A: Для этого служит метод read() он возвращает коллекцию полей
const std::map<const std::string, boost::any>


Q: А как получить список связей?

A: Тем же методом read(name) - значение, которое он возвратит можно привести к
типу const std::vector<Object *>.


Q: Хорошо, я все понял, кроме одного, как удалить объект?

A: Для этого служит метод remove(object) класса AbstractUI.


Q: Ой... а есть способ хранить объекты как-то поудобнее?

A: Конечно. Во первых все объекты хранятся внутри AbstractUI класса, благодаря
этому можно искать объекты по их полям. Во вторых, никто не мешает Вам
использовать ту структуру данных, которую вы считаете наиболее для этого
подходящей.


Q: А как воспользоваться поиском?

A: Поиск осуществляется методом search(parameters), в качестве аргумента ему
нужно передать const std::map<std::string, boost::any>, содержащий пары имя
поля - значение. Если вызвать поиск без параметров методом search(), будут
возвращены все объекты.


# Модули

Q: Каких типов бывают модули?

A: На данный момент модули могут быть трех типов:

 * Модули пользовательского интерфейса;
 * Модули хранения данных;
 * Модуль пакета алгоритмов

Q: Что из себя представляет модуль?

A: Модуль это динамически загружаемая библиотека с особым внутренним строением,
при запуске программы осуществляется поиск и загрузка всех модулей, которые
удастся найти, с помощью опций --iface и --storage можно явно указать, какой
модуль нужно выбрать в качестве интерфейса и базы данных соответственно.


Q: Как устроен модуль?

A: В модуле должен быть реализован класс, унаследованный от
Core::AbstractStorage или Core::AbstractUI. ВНИМАНИЕ: Должны быть реализованы
все виртуальные методы, ни конструктор, ни виртуальные методы не должны быть
внутри тела класса.

Также в модуле должна быть реализована функция init следующего вида:

    extern "C" {
    
    void init(std::vector<Core::Module *>* modules, void *handle)
    {
        new MyModuleClass(modules, handle);
    }

    };

В данном примере _MyModuleClass_ - имя класса модуля.

Q: OMG! Как это работает?

A: **ATTENTION: hardcore.**

Во время загрузки модулей код загрузки ищет по директориям, указанным в
переменной UNISCHED_MODULES_PATH. После удачной попытки загрузить модуль
происходит поиск и вызов функции init реализованной в этом модуле.

Параметрами функции init передаются указатель на вектор с указателями на все
уже загруженные модули и указатель на ELF заголовок модуля в памяти. Первое
нужно конструктору класса Core::Module (базовый для Core::AbstractUI и 
Core::AbstractStorage), чтобы зарегистрировать модуль (иначе он не может быть
выбран для работы), второе - коду, который выгружает модули из памяти.


# Алгоритмы

Q: Это всё хорошо, но может ли эта махина делать что-нибудь полезное?

A: Задачи, решение которых требуется от программы, решаются с помощью механизма
алгоритмов.

Q: Что из себя представляет этот механизм?

A: Каждый алгоритм - это функция на языке lua, занесенная в таблицу глобальную
algorithms. Скрипты в данном случае имеют большое преимущество перед C++ кодом -
они гораздо проще в написании, а также их не обязательно компилировать. 

Q: Есть какие нибудь требования к этим алгоритмам, помимо занесения в массив
algorithms?

A: Нет.


Q: А как мне вызвать алгоритм?

A: Интерпретатор языка lua встроен в класс AbstractUI, поэтому достаточно через
его функции вызвать нужный алгоритм. К примеру такой код должен вызвать алгоритм
повторения события (event - это объект события, которое требуется повторить):

    lua_getglobal(vm(), "algorithms");  // Получить таблицу algorithms
    lua_getfield(vm(), -1, "repeat");   // Получить функцию repeat
    if (lua_isnil(vm(), -1))            // Если функция не найдена
    {
        lua_pop(vm(), 2);                   // Очистить стек интерпретатора
        return;                             // Прервать вызов алгоритма
    }
    _lua_create_lua_object(vm(), event);// Создать lua объект, соответствующий
                                        // объекту C++
    lua_call(vm(), 1, 0);               // Вызвать функцию с одним аргументом,
                                        // без возвращаемых значений
    lua_pop(vm(), 1);                   // Очистить стек интерпретатора

Q: А можно по-подробнее, как работает вызов функции lua?

A: Все взаимодействие с интерпретатором происходит через его стек. Сначала на
вершину стека нужно положить экземпляр функции, потом её аргументы (по порядку)
и вызвать функцию lua_call (или lua_pcall), указав количество аргументов и
количество возвращаемых значений.


Q: Почему для алгоритмов выбран именно lua?

A: lua - это встраиваемый скриптовый иперативный, функциональный, объектно-
ориентированный (прототипный) язык со слабой, динамической (утиной) типизацией
данных, поддерживающий компиляцию. Он был выбран потому что он гибок, прост в
изучении и его очень просто встроить в программу.


Q: Я хочу реализовать алгоритм, я выучил lua, как мне взаимодействовать с ядром
программы?

A: Очень просто.

 * Внесите свою функцию в глобальную таблицу algorithms.
 * Используйте объекты точно также, как объекты C++.
 * В данный момент реализованы следующие функции и объекты:
    
    search(args)    -- Поиск объектов. Принимает таблицу с аргументами поиска.
                    -- Например: search({name = 'John', surname = 'Connor'})
                    -- Возвращает таблицу, содержащую все найденные объекты.
    
    create(type)    -- Создать объект. Принимает строку, указывающую тип
                    -- создаваемого объекта, например:
                    -- object = create('person')
                    -- type может быть равен 'person', 'group' или 'event'.
                    -- Возвращает созданный объект.
    
    remove(object)  -- Удалить объект. Принимает объект, который требуется
                    -- удалить.

    object.type()   -- Возвращает тип объекта ('person', 'group' или 'event')

    object.read(name)   -- Возвращает значение поля с именем name

    object.update(name) -- Создает/изменяет значение поля с именем name

    object.connect(with)    -- Связать объекты.

    object.disconnect(with) -- Разобрать связь между объектами

    object[name]    -- Доступ к полю name в зависимости от использования
    object.name     -- вызывается object.read(name) или object.update(name)
                    -- считайте это синтаксическим сахаром.

# Прочее

Q: Это всё? а у меня еще полно вопросов!

A: На этом у меня фантазия кончилась. Если после всего выше прочитанного еще
остались вопросы, значит вы можете убиться об стенку или изучать код.

